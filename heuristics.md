# Heuristic Function for Crate Delivery Domain (Problem 0.5)

This heuristic estimates the cost-to-go for each crate based on the distance from movers, pending actions (pickup, release, loading), and the number of movers. It is designed to be informative yet efficient for use in symbolic planners like ENHSP.

## Heuristic Definition

We define the heuristic function h(n) for a state n as:

```math
h(n) = \sum_{i=0}^{c} \sum_{j=0}^{m} \left[ (bp \cdot d_{ij} + br \cdot d_{j}) \cdot m_j \right] + bp \cdot p + br \cdot r + bl \cdot L
```
### Where:

- `c` — Number of crates  
- `m` — Number of movers  
- `d_{ij}` — Distance from mover j to crate i
- `d_{j}` — Distance from mover j to the loading bay   
- `m_j` — Binary or weighted indicator if mover j is available  
- `bp` — Binary flag: 1 if crate i has not been picked up, 0 otherwise  
- `br` — Binary flag: 1 if crate i has not been released, 0 otherwise  
- `bl` — Binary flag: 1 if crate i has not started loading, 0 otherwise  
- `p` — Fixed pickup cost  
- `r` — Fixed release cost  
- `l` — Fixed loading time/cost  

## Component Explanation

- **Pickup Distance Term**: $bp \cdot d_{ij}$ penalizes distance to the crate if it has not yet been picked up.
- **Return Distance Term**: $br \cdot d_{ij}$ penalizes the return trip cost if the crate has not yet been released.
- **Action Costs**:
  - $bp \cdot p$ adds fixed pickup effort
  - $br \cdot r$ adds fixed release effort
  - $bl \cdot l$ adds fixed loading cost if not started
- **Mover Scaling**: All distance terms are scaled by m_j, which represents the number of robots that take part in moving this crate.

## Example Use Case

### Case 1: Standard Crate

For a crate at distance d = 10:
- bp = 1, br = 1, bl = 1
- p = 2, r = 2, L = 4

Then:

h(n) = 2 * 10 + 2 + 2 + 4 = 28

### Case 2: All Actions Completed

If the crate has already been picked, released, and loaded:
- bp = 0, br = 0, bl = 0
- All action costs and distance terms are ignored.

Then:

h(n) = 0

### Case 3: Heavy Crate (Requires Two Movers)

For a heavy crate weighing 70 kg, requiring two movers:
- Assume d = 10
- Both movers are available: m_j = 2
- bp = 1, br = 1, bl = 1
- p = 2, r = 2, L = 4

Then:

h(n) = (1 * 10 + 1 * 10) * 2 + 2 + 2 + 4 = 40 + 8 = 48

### Pseudocode
```
function h(n):
    total_cost = 0

    for each crate i in n.crates:
        bp = 1 if not crate[i].picked_up else 0
        br = 1 if not crate[i].released else 0
        bl = 1 if not crate[i].loaded else 0

        # Action costs (can be constants or state-specific)
        p = crate[i].pickup_cost
        r = crate[i].release_cost
        L = crate[i].loading_cost

        # Number of movers required for this crate
        movers_needed = crate[i].movers_required

        # Get available movers
        available_movers = get_available_movers(n)
        movers_assigned = select_movers(available_movers, movers_needed)

        for mover in movers_assigned:
            d_to_crate = distance(mover.position, crate[i].position)
            d_to_loading_bay = distance(crate[i].position, loading_bay.position)

            cost = (bp * d_to_crate + br * d_to_loading_bay)
            total_cost += cost

        # Add fixed action costs (scaled by 1 crate, not per mover)
        total_cost += (bp * p) + (br * r) + (bl * L)

    return total_cost
```
### Proof of consistency 
we take the plan generated by the domain on problem 0.5 and we remove the extension actions for simplicity

```
0.00000: (start_forward mover2 )
(0.00000,1.00000)------>waiting
1.00000: (start_forward mover1 )
1.00000: (stop_at_crate mover2 crate1 )
(1.00000,2.00000)------>waiting
2.00000: (stop_at_crate mover1 crate1 )
2.00000: (pickup_by_two mover2 mover1 crate1 )
2.00000: (coeff_changer_heavy mover2 mover1 crate1 )
(2.00000,9.00000)------>waiting
9.00000: (stop_handover_by_two mover1 mover2 crate1 loader2 )
9.00000: (start_forward mover2 )
9.00000: (charging_battery mover1 )
(9.00000,11.00000)------>waiting
11.00000: (stop_at_crate mover2 crate2 )
11.00000: (pickup_per_gruppo mover2 crate2 A )
11.00000: (switch_group A )
(11.00000,12.00000)------>waiting
12.00000: (start_forward mover1 )
(12.00000,13.00000)------>waiting
13.00000: (doneload crate1 loader2 )
(13.00000,14.00000)------>waiting
14.00000: (stop_at_crate mover1 crate2 )
(14.00000,15.00000)------>waiting
15.00000: (stop_handover mover2 crate2 loader1 )
15.00000: (start_forward mover2 )
(15.00000,19.00000)------>waiting
19.00000: (doneload crate2 loader1 )
```
becomes
```
0.00000: (start_forward mover2 )
1.00000: (start_forward mover1 )
1.00000: (stop_at_crate mover2 crate1 )
2.00000: (stop_at_crate mover1 crate1 )
2.00000: (pickup_by_two mover2 mover1 crate1 )
9.00000: (stop_handover_by_two mover1 mover2 crate1 loader2 )
9.00000: (start_forward mover2 )
11.00000: (stop_at_crate mover2 crate2 )
11.00000: (pickup_per_gruppo mover2 crate2 A )
12.00000: (start_forward mover1 )
13.00000: (doneload crate1 loader2 )
(13.00000,14.00000)------>waiting
14.00000: (stop_at_crate mover1 crate2 )
(14.00000,15.00000)------>waiting
15.00000: (stop_handover mover2 crate2 loader1 )
15.00000: (start_forward mover2 )
(15.00000,19.00000)------>waiting
19.00000: (doneload crate2 loader1 )
```